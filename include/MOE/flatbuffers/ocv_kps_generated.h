// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OCVKPS_CVFB_H_
#define FLATBUFFERS_GENERATED_OCVKPS_CVFB_H_

#include "flatbuffers/flatbuffers.h"

#include "ocv_mat_generated.h"

namespace cvfb {

struct Point2f;

struct OcvKp;

struct OcvKps;
struct OcvKpsBuilder;

struct OcvKpsAndDescs;
struct OcvKpsAndDescsBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Point2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Point2f()
      : x_(0),
        y_(0) {
  }
  Point2f(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Point2f, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) OcvKp FLATBUFFERS_FINAL_CLASS {
 private:
  float angle_;
  int32_t class_id_;
  int32_t octave_;
  cvfb::Point2f pt_;
  float response_;
  float size_;

 public:
  OcvKp()
      : angle_(0),
        class_id_(0),
        octave_(0),
        pt_(),
        response_(0),
        size_(0) {
  }
  OcvKp(float _angle, int32_t _class_id, int32_t _octave, const cvfb::Point2f &_pt, float _response, float _size)
      : angle_(flatbuffers::EndianScalar(_angle)),
        class_id_(flatbuffers::EndianScalar(_class_id)),
        octave_(flatbuffers::EndianScalar(_octave)),
        pt_(_pt),
        response_(flatbuffers::EndianScalar(_response)),
        size_(flatbuffers::EndianScalar(_size)) {
  }
  float angle() const {
    return flatbuffers::EndianScalar(angle_);
  }
  int32_t class_id() const {
    return flatbuffers::EndianScalar(class_id_);
  }
  int32_t octave() const {
    return flatbuffers::EndianScalar(octave_);
  }
  const cvfb::Point2f &pt() const {
    return pt_;
  }
  float response() const {
    return flatbuffers::EndianScalar(response_);
  }
  float size() const {
    return flatbuffers::EndianScalar(size_);
  }
};
FLATBUFFERS_STRUCT_END(OcvKp, 28);

struct OcvKps FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OcvKpsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_KPS = 6
  };
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  const flatbuffers::Vector<const cvfb::OcvKp *> *kps() const {
    return GetPointer<const flatbuffers::Vector<const cvfb::OcvKp *> *>(VT_KPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SIZE, 4) &&
           VerifyOffset(verifier, VT_KPS) &&
           verifier.VerifyVector(kps()) &&
           verifier.EndTable();
  }
};

struct OcvKpsBuilder {
  typedef OcvKps Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(OcvKps::VT_SIZE, size, 0);
  }
  void add_kps(flatbuffers::Offset<flatbuffers::Vector<const cvfb::OcvKp *>> kps) {
    fbb_.AddOffset(OcvKps::VT_KPS, kps);
  }
  explicit OcvKpsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OcvKps> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OcvKps>(end);
    return o;
  }
};

inline flatbuffers::Offset<OcvKps> CreateOcvKps(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<const cvfb::OcvKp *>> kps = 0) {
  OcvKpsBuilder builder_(_fbb);
  builder_.add_kps(kps);
  builder_.add_size(size);
  return builder_.Finish();
}

inline flatbuffers::Offset<OcvKps> CreateOcvKpsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t size = 0,
    const std::vector<cvfb::OcvKp> *kps = nullptr) {
  auto kps__ = kps ? _fbb.CreateVectorOfStructs<cvfb::OcvKp>(*kps) : 0;
  return cvfb::CreateOcvKps(
      _fbb,
      size,
      kps__);
}

struct OcvKpsAndDescs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OcvKpsAndDescsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KPS = 4,
    VT_DESCS = 6
  };
  const cvfb::OcvKps *kps() const {
    return GetPointer<const cvfb::OcvKps *>(VT_KPS);
  }
  const cvfb::OcvMat *descs() const {
    return GetPointer<const cvfb::OcvMat *>(VT_DESCS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KPS) &&
           verifier.VerifyTable(kps()) &&
           VerifyOffset(verifier, VT_DESCS) &&
           verifier.VerifyTable(descs()) &&
           verifier.EndTable();
  }
};

struct OcvKpsAndDescsBuilder {
  typedef OcvKpsAndDescs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kps(flatbuffers::Offset<cvfb::OcvKps> kps) {
    fbb_.AddOffset(OcvKpsAndDescs::VT_KPS, kps);
  }
  void add_descs(flatbuffers::Offset<cvfb::OcvMat> descs) {
    fbb_.AddOffset(OcvKpsAndDescs::VT_DESCS, descs);
  }
  explicit OcvKpsAndDescsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OcvKpsAndDescs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OcvKpsAndDescs>(end);
    return o;
  }
};

inline flatbuffers::Offset<OcvKpsAndDescs> CreateOcvKpsAndDescs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<cvfb::OcvKps> kps = 0,
    flatbuffers::Offset<cvfb::OcvMat> descs = 0) {
  OcvKpsAndDescsBuilder builder_(_fbb);
  builder_.add_descs(descs);
  builder_.add_kps(kps);
  return builder_.Finish();
}

inline const cvfb::OcvKpsAndDescs *GetOcvKpsAndDescs(const void *buf) {
  return flatbuffers::GetRoot<cvfb::OcvKpsAndDescs>(buf);
}

inline const cvfb::OcvKpsAndDescs *GetSizePrefixedOcvKpsAndDescs(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<cvfb::OcvKpsAndDescs>(buf);
}

inline bool VerifyOcvKpsAndDescsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<cvfb::OcvKpsAndDescs>(nullptr);
}

inline bool VerifySizePrefixedOcvKpsAndDescsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<cvfb::OcvKpsAndDescs>(nullptr);
}

inline void FinishOcvKpsAndDescsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cvfb::OcvKpsAndDescs> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOcvKpsAndDescsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cvfb::OcvKpsAndDescs> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace cvfb

#endif  // FLATBUFFERS_GENERATED_OCVKPS_CVFB_H_
